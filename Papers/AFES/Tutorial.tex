In this section we introduce the usage of AFES by the use of examples. The AFES
api is written solely in Python (with the exception of UFL for the weak form)
and thus the user is expected to have a basic knowledge of Python programming.
However, since AFES is based on the FEniCS/DOLFIN Python interface it does not
compromise on performance\cite{Alnae2011}. The use of DOLFIN's Python interface
allows for greater ease of use, as compared to the C++ interface. Eventually, we
intend to offer a GUI which would require the use of no programming and only
entering the details for the domain, boundary conditions, and the weak form.

\subsection{Solving a PDE} \label{sse:Solver}

    In this subsection we explain how to solve a basic time dependent PDE using
    the AFES api. We choose to explain the API through example; we choose to
    make things quite simple at first and so the first example is the Heat
    equation.  Since, the FEM requires the weak form of any PDE we assume
    the user understands how to determine the weak form for a given PDE and thus
    no explanation of the weak form is given. For a very basic explanation of
    the weak form see \cite[Chapter 6.2.2]{Eriksson2009}.

    Of course to be able to solve any PDE certain assumptions must be made. AFES
    makes the assumption that an $H^1$ FE is appropriate for solving the given
    PDE, i.e. the FE discretization is stable. Additionally, AFES assumes the

    \begin{equation}
        R(u) = u_t - F(u;t) = 0.
        \label{eq:BasicForm}
    \end{equation}
    AFES also assumes that the given PDE can be discretized in time in the
    following way
    \begin{equation}
        r(u^n, u^n, v) = \frac{1}{k} (u^n - u^{n-1}, v) - (F(\hat{u};t^n), v) = 0,
        \label{eq:WeakResidual}
    \end{equation}
    where $u^n,\, u^{n-1},\, \hat{u}$, and $v$ are the solution at the
    $n^{th}$-timestep, the solution at the $(n-1)^{st}$-timestep,
    $\theta$-weighted average of the solution for the $n^{th}$ and
    $(n-1)^{th}$-timestep, i.e.
    \begin{equation}
        \hat{u} = \theta\, u^n + (1 - \theta)\, u^{n-1},
        \label{eq:uAvg}
    \end{equation}
    and the test function, respectively.

\subsubsection{Heat Equation} \label{sss:Heat}
    The heat equation is a canonical example of parabolic partial differential
    equations. Given the domain $\Omega$ with boundary $\partial \Omega$ and
    time interval $I$ the heat equation is given by
    \begin{equation}
        \begin{split}
            u_t - \nabla \left( \kappa \nabla u \right) &= f
                \qquad (\mathbf{x}, t)\in \Omega \times I \\
            u(\mathbf{x}, 0) &= u_0(\mathbf{x}) \quad \mathbf{x} \in \Omega \\
            u(\mathbf{x}, t) &= g(\mathbf{x},t) \quad (\mathbf{x}, t)\in
                \partial\Omega \times I, \\
        \end{split}
        \label{eq:Heat}
    \end{equation}
    where $f$ is the internal heat source/sink and $g$ is the boundary
    condition. Taking our FE basis functions $v_h\in V^h\subset H^1_0(\Omega)$
    then we are trying to find a $u^n_h \in V^h \subset H^1(\Omega)$ such that
    \begin{equation}
        \frac{1}{k} (u^n - u^{n-1}, v_h) + (\kappa \nabla \hat{u}, \nabla v_h) =
        0 \quad \forall v_h \in V^h,
        \label{eq:WeakHeat}
    \end{equation}
    where $k$ is the time step, $u^n_h$ is the FE solution at the
    $n^{th}$-timestep, $u^{n-1}_h$ is the FE solution at the
    $(n-1)^{st}$-timestep, $\hat{u}$ is given by \eqref{eq:uAvg}, and $\kappa$
    is the heat coefficient. To further
    specify the problem we will define the domain to be the unit square, i.e.
    \begin{equation}
        \Omega := [0, 1] \times [0, 1],
        \label{eq:HeatDomain}
    \end{equation}
    let the initial condition be
    \begin{equation}
        u0 := \sin(pi\, x)\, \sin(pi\, y)
        \label{eq:HeatIC}
    \end{equation}
    define the function to be
    \begin{equation}
        f(x,y,t) := 0
        \label{eq:HeatSource}
    \end{equation}
    and the boundary condition to be
    \begin{equation}
        g(x,y,t) := 0
        \label{eq:HeatBC}
    \end{equation}

    Just as in the definition of the PDE AFES requires certain things to be
    defined. First, we can define the mesh (we will use a
    \texttt{UnitSquareMesh} as our domain), and then the mesh must be passed to
    the \texttt{Problem} class. This can be done in the following way
    \lstinputlisting[firstline=61,lastline=66,numbers=none]{Heat.py}
    we need to define the initial conditions and
    boundary conditions. For the initial condition, \eqref{eq:HeatIC}, and
    the boundary condition, \eqref{eq:HeatBC}, these functions can be defined
    as follows
    \lstinputlisting[firstline=10,lastline=20,numbers=none]{Heat.py}
    To be able to access these functions AFES needs them define. To do this we
    must pass the functions to AFES' \texttt{Problem} class. This is done quite
    easily in the following way
    \lstinputlisting[firstline=71,lastline=72,numbers=none]{Heat.py}
    To define the heat source/sink things are actually a bit easier and the user
    need only to pass the function directly to the \texttt{Problem} class. This
    is done in a quite similar way as to the way we passed the ICs and BCs, as
    can be seen below
    \lstinputlisting[firstline=68,lastline=68,numbers=none]{Heat.py}
    In fact, this could be left out if the user does not require it in the weak
    form, but we include it here for completeness.

    Next, we need to create our function space; here we will choose $P^1$ finite
    elements, i.e. piecewise linear basis functions. To do this we create a
    function named \texttt{function\_space}. However, this time we will pass the
    functions to the \texttt{Solver} class. Then we can also define our weak
    form by defining the functions \texttt{weak\_residual}. Similar to
    \texttt{function\_space} we then pass it to the \texttt{Solver} class in the
    same way we passed \texttt{functions\_space}. The definition of the function
    space and the weak form given by \eqref{eq:WeakHeat} can be seen below
    \lstinputlisting[firstline=28,lastline=44,numbers=none]{Heat.py}
    These functions are then passed to the \texttt{Solver} class in the
    following way
    \lstinputlisting[firstline=78,lastline=79,numbers=none]{Heat.py}

    In addition to the standard functions above, we can define some auxiliary
    functions. Some examples are \texttt{Plot}, \texttt{Name}, and \texttt{Save}
    functions; AFES assumes the equation given is similar to the Navier-Stokes
    equation, i.e. the first variable is a vector function and the second
    variable is a scalar function, thus it may be necessary to override the
    built in functionality so as to fit your own specifics. For this example we
    only override the \texttt{Plot} function; this is done in much the same way
    as we did for the other functions already seen above.
    \lstinputlisting[firstline=47,lastline=54,numbers=none]{Heat.py}
    \lstinputlisting[firstline=80,lastline=80,numbers=none]{Heat.py}

    The entire code can be viewed below
    \lstinputlisting[numbers=none]{Heat.py}

    While from a coders point of view this looks more complicated than the
    standard heat equation solver in the FEniCS demos, the beauty of this code
    is that the main() portion of the script remains mostly unchanged from
    problem to problem. The power of this approach can be seen in the
    following code snippets
    \lstinputlisting[numbers=none,firstline=77,lastline=79]{Heat.py}
    and
    \lstinputlisting[numbers=none,firstline=70,lastline=73]{Heat.py}
    With this approach we can easily mix and match problems and solvers. Thus,
    we can use the same main() to run, say, the heat equation or even the
    Navier-Stokes equations (on a simple domain).

\subsubsection{Navier-Stokes Equations} \label{sss:NSE}

    In this subsection we demonstrate the use of AFES on a more complicated
    example, namely the Navier-Stokes equations for flow around a cylinder.  We
    discretize the Navier-Stokes equations using a Galerkin\slash~Least-Squares
    (GLS) stabilized cG(1)cG(1) finite element, where the first cG(1) indicates
    that the test and trial functions are both piecewise linear, while the
    second cG(1) indicates that the test piecewise constants and the trial
    functions are continuous piecewise linear (see \cite{Hoffman2006a} for more
    details).

    For this problem we are concerned with modelling the incompressible
    Navier-Stokes equations with constant kinematic viscosity, $\nu>0$, in a
    domain $\Omega\subset \R^d$, with boundary $\partial \Omega$, i.e.  where
    the strong residual is given by
    \begin{equation}
        \begin{split}
            \mathbf{u}_t + \left( \mathbf{u} \cdot \nabla \right) \mathbf{u}
                - \nu\, \Delta \mathbf{u} + \nabla p = \mathbf{f},
                    \quad \mathbf{x} \in \Omega \\
            \nabla \cdot \mathbf{u} = 0, \quad \mathbf{x} \in \Omega
        \end{split}
    \label{eqn:NSE}
    \end{equation}
    Given a step size $k$ and applying the cG(1)cG(1) finite element discretization
    to \eqref{eqn:NSE} with $V = (v, q) \in X \subset [H^1_0(\Omega)]^d \times
    H^1(\Omega)$ gives the following weak residual
    \begin{equation}
    \begin{split}
        r(\bar{U}^n; V) &= \left(\mathbf{u}^n - \mathbf{u}^{n-1}\right)\,k^{-1}
            + (\left( \bar{\mathbf{u}}^n \cdot \nabla \right) \bar{\mathbf{u}}^n, v) \\
            &\quad+ \nu\, (\nabla \bar{\mathbf{u}}^n, \nabla v)
            - (p^n, \nabla \cdot v) - (\mathbf{f}, v)
            + (\nabla \cdot \bar{\mathbf{u}}^n, v) = 0
    \end{split}
    \label{eqn:WeakNSE}
    \end{equation}
    where $\bar{U}^n = (\bar{\mathbf{u}}^n,p)$, and $\bar{\mathbf{u}}^n =
    \frac{1}{2}\left(\mathbf{u}^n + \mathbf{u}^{n-1}\right)$. Given the solution
    $U=(\mathbf{u},p)$, since the elements we are concerned with (cG(1)cG(1)) have
    test functions which are linear in space and constant in time the strong
    residual is given by
    \begin{equation}
        R(\bar{U}^n,U) = \begin{cases}
        \left(\mathbf{u} \cdot \nabla \right) \bar{\mathbf{u}}^n
            + \nabla p^n - \mathbf{f} = 0 \\
        \nabla \cdot \bar{\mathbf{u}}^n = 0.
        \end{cases}
    \label{eqn:StrongNSE}
    \end{equation}
    \textcolor{red}{Should $\mathbf{f}$ be an average between time steps?}
    Finally, the GLS-cG(1)cG(1) discretization of \eqref{eqn:NSE} is given by
    \begin{equation}
    r(\bar{U}^n,V) + SD_{\delta}^n(\bar{U}^n,V) = 0, \quad \forall V=(v,q) \in X.
    \label{eqn:G2}
    \end{equation}
    Here $SD_{\delta}^n$ is the GLS and is given by
    \begin{equation}
    SD_{\delta}^n \equiv
        \delta_1 (\left(\bar{\mathbf{u}}^n \cdot \nabla \right) \bar{\mathbf{u}}^n
            + \nabla p^n - \mathbf{f},
        \left(\bar{\mathbf{u}}^n \cdot \nabla \right) v + \nabla q)
        + \delta_2 (\nabla \cdot \bar{\mathbf{U}}^n, \nabla \cdot v),
    \label{eqn:NSEStabilization}
    \end{equation}
    where $\delta_1 = \kappa_1 (k^{-1} + |\mathbf{u}^{n-1}|^2\, h^{-2})^{-1/2}$, and
    $\delta_2 = \kappa_2 h$, while $\kappa_1$ and $\kappa_2$ are problem independent
    constants of unit size. For each test case below we take the time-step to be
    \begin{equation*}
    k = C_{CFL}\, \frac{\min_{\mathcal{T}_K}(h)}{|U_m|},
    \end{equation*}
    where $C_{CFL}=10$.

    This test case is based on a benchmark problem from Sch\"afer and Turek
    \cite[Test case 2D-2]{Schaefer1996}. Thus, we define the domain to be a
    rectangular domain with a circle removed (see \autoref{fig:2DCylinder}). For
    the inlet boundary condition we take
    \begin{equation}
        u(0,y,t) = (4\, U_m\,y\, (H - y)/H^2, 0),
        \label{eqn:2DInlet}
    \end{equation}
    where $U_m = 1.5\, \text{m/s}$, $H = 0.41\, \text{m}$. For the kinematic
    viscosity we take $\nu = 10^{-3}\, \text{m}^2\text{/s}$, resulting in a
    Reynolds number of $Re=100$.

    \begin{figure}[h]
        \centering
        \tikzstyle{next}=[->, thick, shorten <=1pt, shorten >=1pt]
        \begin{tikzpicture}[scale=6]
            \draw (0,0) -- (2.2,0) -- (2.2,0.41) -- (0,0.41) -- cycle;
            \draw (0.2,0.2) circle (0.05);
            \draw[<->] (0,-0.05) -- (2.2,-0.05);
            \draw (1.1,-0.1) node {2.2 m};
            \draw[<->] (0,0.2) -- (0.15,0.2);
            \draw (0.075,0.25) node {\footnotesize 0.15 m};
            \draw[<->] (0.2,0) -- (0.2,0.15);
            \draw (0.3,0.075) node {\footnotesize 0.15 m};
            \draw[<->] (0.2,0.25) -- (0.2,0.41);
            \draw (0.3,0.31) node {\footnotesize 0.16 m};
            \draw[<->] (0.3,0.15) -- (0.3,0.25);
            \draw (0.4,0.2) node {\footnotesize 0.1 m};
            \node[rotate=90] (outflow) at (2.25, 0.2) {Outlet};
            \node[rotate=90] (inflow) at (-0.05, 0.2) {Inlet};
            \node (NoFlow) at (1.1,0.5) {$u=v=0$};
            \draw[next] (NoFlow) to (1.1,0.41);
            \draw[next] (NoFlow) to [out=-45,in=45] (1.1,0);
            \draw[next] (NoFlow) to [out=-135,in=-35] (0.25,0.15);
        \end{tikzpicture}
        \caption{Problem Geometry, $\Omega$}
        \label{fig:2DCylinder}
    \end{figure}

    \lstinputlisting[numbers=none]{NSE.py}

\subsection{Goal Oriented Adaptivity} \label{sse:Adaptivity}

\subsubsection{Navier-Stokes Equation} \label{sss:AdaptiveNSE}
    \lstinputlisting[numbers=none]{NSE.py}

\subsection{Optimization} \label{sse:Optimization}
