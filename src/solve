#!/usr/bin/python
__author__ = "Erich L Foster <erichlf@gmail.com>"
__date__ = "2013-08-27"
__license__  = "GNU GPL version 3 or any later version"
#
#   adapted from ns in nsbench originally developed by
#   Anders Logg <logg@simula.no>
#

import sys, commands, time
import re

from dolfin import set_log_active, parameters, list_timings, NewtonSolver
from problems import Problem, problems 
from solvers import Solver, solvers

# Default options
OPTIONS = { "Nx": 20, #number of elements along x axis
	    "Ny" : 20, #number of elements along y axis
            "dt": 0.01, #time-step
            "T": 1.0, #final-time
            "Re": 1000, #Reynolds number
            "Ro": 0.0125, #Rossby number
            "Fr": 1, #Froude number
            "Theta": 6.25, #wave deflection number
            "H": 1, #water depth
            "F1": '(0,0)', #momentum forcing function
            "F2": '0', #mass source/sink
            "x0": '-5', #x-coordinate of the bottom-left corner
            "x1": '10', #x-coordinate of the top-right corner
            "y0": '-2', #y-coordinate of the bottom-left corner
            "y1": '2', #y-coordinate of the top-right corner
            "lambda0": '20', #Typical wavelength for scaling
            "alpha": 0.5, #time-stepping method
            "save_solution": True,
            "save_frequency": 1,
            "plot_solution": False,
            "debug": False,
            "check_mem_usage": False,
            "absolute_tolerance": 1e-25,
            "relative_tolerance": 1e-12,
            "monitor_convergence": False,
            "velocity_order": 1, #order of velocity element
            "height_order": 1, #order of height/pressure element
            "stabilize": True, #stabilize?
            "linear": False, #use the linear version?
            "inviscid": False #use the inviscid version?
            }

def usage():
#   Print usage
    print """\
Usage: solve solver problem (run solver for given problem)
solve solver (run solver for channel flow.)
solve problem (run NSE for problem.)

Options are submitting in the form option=value

Available solvers:
%s

Available problems:
%s 

Available options: (option = default value)
%s
""" % ('\n'.join('  ' + s for s in solvers),
       '\n'.join('  ' + p for p in problems),
       '\n'.join('  ' + key + ' = ' + str(value) \
               for key, value in OPTIONS.iteritems()))

def main(args):
#   Parse command-line arguments and run solver.

    # Extract arguments (note: don't change the order here!)
    params = [arg for arg in args if "=" in arg]
    args = [arg for arg in args if not "=" in arg]

    # Decide list of problems and solvers based on command-line arguments
    if len(args) < 1:
        usage()
        return 1
    elif len(args) == 1 and args[0] in problems:
        solver_name = 'SWE'
        problem_name = args[0]
    elif len(args) == 1 and args[0] in solvers:
        solver_name = args[0]
        problem_name = 'Drop'
    elif len(args) == 2 and args[0] in solvers and args[1] in problems:
      solver_name, problem_name = args[:2]
    else:
        usage()
        return 1

    # Get options
    options = OPTIONS.copy()
    for parameter in params:
        try:
            #key, value = parameter.split("=")
            key, value = parameter.split('=',1)
            try:
                options[key] = eval(value)
            except:
                options[key] = str(value)
        except:
            print 'Warning: Unhandled command-line argument', parameter

    #the momentum forcing function needs to be made into a vector of strings
    #options['F1'] = [
    pattern = re.compile('^\((.+),\s*(.+)\)$')
    m = pattern.match(str(options['F1']))
    options['F1'] = [m.group(1), m.group(2)]

    # Set global DOLFIN parameters
    parameters['form_compiler']['cpp_optimize'] = True
    parameters['allow_extrapolation'] = True;
    nonLinearSolver = NewtonSolver()
    prm = nonLinearSolver.parameters
    prm['convergence_criterion'] = 'incremental' 
    prm['absolute_tolerance'] = options["absolute_tolerance"]
    prm['relative_tolerance'] = options["relative_tolerance"]
    prm['report'] = options["monitor_convergence"]

    # Set debug level
    set_log_active(options["debug"])

    sys.stdout.write('Solving %s for the %s problem.\r' % (solver_name,problem_name))
    # Create problem and solver
    problem = Problem(problem_name, options)
    solver = Solver(solver_name, options)

    # Solve problem with solver
    wct = time.time()
    u, p = solver.solve(problem)

    # Compute elapsed time
    wct = time.time() - wct

    # Compute number of degrees of freedom
    #num_dofs = u.vector().size() + p.vector().size()
    sys.stdout.flush()
    sys.stdout.write('\033[K')
    sys.stdout.write('Solved %s for the %s problem in %g seconds.\n' %
            (solver_name,problem_name,wct))

    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
