#!/usr/bin/python
__author__ = "Erich L Foster <efoster@bcamath.org>"
__date__ = "2013-08-27"
__license__  = "GNU GPL version 3 or any later version"
#
#   adapted from ns in nsbench originally developed by
#   Anders Logg <logg@simula.no>
#

import sys, commands, time

from dolfin import set_log_active, parameters, list_timings, NewtonSolver
from problems import Problem, problems 
from solvers import Solver, solvers

# Default options
OPTIONS = { "N": 32, #number of elements along an axis
            "dt": 0.01, #time-step
            "T": 1.0, #final-time
            "nu": 0.01, #kinematic viscosity
            "f0": 6.16E-5, #reference coriolis force
            "beta": 2.07E-11, #beta plane parameter
            "g": 9.81, #gravitational constant
            "H": 1.63, #water depth
            "theta": 0.5, #theta for the theta time-stepping method
            "save_solution": True,
            "save_frequency": 1,
            "plot_solution": False,
            "debug": False,
            "check_mem_usage": False,
            "absolute_tolerance": 1e-25,
            "relative_tolerance": 1e-12,
            "monitor_convergence": False,
            "linear_solver": 'lu',
            "velocity_order": 1, #order of velocity element
            "height_order": 1, #order of height/pressure element
            "stabilize": True, #stabilize?
            "linear": False #use the linear version?
            }

def usage():
#   Print usage
    print """\
Usage: solve solver problem (run solver for given problem)
solve solver (run solver for channel flow.)
solve problem (run NSE for problem.)

Options are submitting in the form option=value

Available solvers:
%s

Available problems:
%s 

Available options: (option = default value)
%s
""" % ('\n'.join('  ' + s for s in solvers),
       '\n'.join('  ' + p for p in problems),
       '\n'.join('  ' + key + ' = ' + str(value) \
               for key, value in OPTIONS.iteritems()))

def main(args):
#   Parse command-line arguments and run solver.

    # Extract arguments (note: don't change the order here!)
    params = [arg for arg in args if "=" in arg]
    args = [arg for arg in args if not "=" in arg]

    # Decide list of problems and solvers based on command-line arguments
    if len(args) < 1:
        usage()
        return 1
    elif len(args) == 1 and args[0] in problems:
        solver_name = 'SWE'
        problem_name = args[0]
    elif len(args) == 1 and args[0] in solvers:
        solver_name = args[0]
        problem_name = 'Drop'
    elif len(args) == 2 and args[0] in solvers and args[1] in problems:
      solver_name, problem_name = args[:2]
    else:
        usage()
        return 1

    # Get options
    options = OPTIONS.copy()
    for parameter in params:
        try:
            key, value = parameter.split("=")
            try:
                options[key] = eval(value)
            except:
                options[key] = str(value)
        except:
            print 'Warning: Unhandled command-line argument', parameter 

    # Set global DOLFIN parameters
    parameters['form_compiler']['cpp_optimize'] = True
    parameters['allow_extrapolation'] = True;
    nonLinearSolver = NewtonSolver(options["linear_solver"])
    prm = nonLinearSolver.parameters
    prm['convergence_criterion'] = 'incremental' 
    prm['absolute_tolerance'] = options["absolute_tolerance"]
    prm['relative_tolerance'] = options["relative_tolerance"]
    prm['report'] = options["monitor_convergence"]

    # Set debug level
    set_log_active(options["debug"])

    sys.stdout.write('Solving %s for the %s problem.\r' % (solver_name,problem_name))
    # Create problem and solver
    problem = Problem(problem_name, options)
    solver = Solver(solver_name, options)

    # Solve problem with solver
    wct = time.time()
    u, p = solver.solve(problem)

    # Compute elapsed time
    wct = time.time() - wct

    # Compute number of degrees of freedom
    #num_dofs = u.vector().size() + p.vector().size()
    sys.stdout.flush()
    sys.stdout.write('\033[K')
    sys.stdout.write('Solved %s for the %s problem in %g seconds.\n' %
            (solver_name,problem_name,wct))

    return 0

if __name__ == "__main__":
    sys.exit(main(sys.argv[1:]))
